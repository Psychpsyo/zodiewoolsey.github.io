<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="Style.css">
        <script language="javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js" type="text/javascript"></script>
        <script language="javascript" src="jqinput/jquery.hotkeys.js" type="text/javascript"></script>
        <script language="javascript" src="jqinput/key_status.js" type="text/javascript"></script>
        <script language="javascript" src="jqinput/util.js" type="text/javascript"></script>
        <script language="javascript" src="jqinput/sprite.js" type="text/javascript"></script>
        <script language="javascript" src="jqinput/sound.js" type="text/javascript"></script>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({
          google_ad_client: "ca-pub-7557515487848783",
          enable_page_level_ads: true
     });
</script>
    </head>
    <body>
        <h1>Pattern Game</h1>
        <p style="text-align: center;">
        Make all the squares the same color!
        (PS: start in the top left one)
        </p>
        <div class="centerCanvas">
        <canvas id="canvas">.</canvas>
        </div>
        <div id="score" style="text-align: center"></div>
        <script>
            var c = document.getElementById("canvas");//Creates connection to canvas element on the page
            var ctx = c.getContext("2d");//Creates a 2d context object for the canvas element
            var scoretag = document.getElementById("score");//Creates a connection to the score element on the page
            
            c.onmousemove = mousepos;//sets the onmousemove event of the canvas to my mousepos function
            c.onmousedown = mousedown;//sets onmousedown event of the canvas to my mousedown function
            c.onmouseup = mouseup;//sets onmouseup event of the canvas to my mouseup function
            
            var oldTime = Date.now();//date element for screen update timings
            
            c.width = 500;//sets width of canvas renderer in pixels
            c.height = 500;//sets height of canvas renderer in pixels
            
            //creates zeroed out vriables for int:mouseX , int:mouseY and bool:mouseclick
            var mouseX = 0;
            var mouseY = 0;
            var mouseclick = false;
            
            //sets scale of game by number of panels (size=10 is a 10x10 square)
            var size = 10;
            //variable defining base number of mixes for difficulty scaling
            var difficulty = 1;
            
            //creates zeroed out variables for int:turn , int:score
            var turn = 0;
            var score = 0;
            //array for the different locations on the game grid and their current color values
            var positions = [];
            //function for generating all blue positions to initialize the correctly sized array for the game grid
            function genPos(){
                for (p = 0; p < size; p++){
                    positions.push([]);
                    for (o = 0; o < size; o++){
                            positions[p].push("b");
                        }
                }
                return positions;
            }
            positions = genPos();//runs genPos to set the array:position variable to the generated array
            
            //positions[0][0] = "h";
            //console.log(positions);
            
            
            //function for parsing exact mouse position so it does not include extra space from dom padding/margin/etc.
            function mousepos(event){
                mouseX = event.clientX - c.getBoundingClientRect().left;
                mouseY = event.clientY - c.getBoundingClientRect().top;
            };
            //function to define whether the mouse has been clicked
            function mousedown(){
                mouseclick = true;
            };
            //function to define whether the mouse has been unclicked
            function mouseup(){
                mouseclick = false;
            }
            
            //full game function
            function thegame(){
                var obj = {};//object for oop js for instancing the game
                obj.width = c.width/positions.length;//parses array width for game grid size calibration
                obj.height = c.height/positions[0].length;//same as above for height
                
                //the two variables below are required because of the logic of the game
                //if the outer edges of the game were selectable, the simple logic would break
                //this would cause patterns that do not fit within the desired logic of the game
                //      this is also a lazy workaround for array reference issues but turns out to preserver game logic as well
                obj.noX = [0,size-1];
                obj.noY = [0,size-1];
                
                obj.mposX = 1;//mouse x position variable
                obj.mXO = 1;
                
                obj.mposY = 1;//mosue y position variable
                obj.mYO = 1;
                
                obj.wait = 0;//poorly named variable to enable only adjacent sqaure activation
                obj.oneColor = "#0f0";//predefined red color for ease of use and color customizability
                obj.twoColor = "#808";//predefined colr for ease of use and color customizability
                obj.threeColor = ["#",0,0,0];//array for having a randomly generated set of colors, I like hex so I wanted it to be converted to hex. However this has major limitations and I wrote this a while back so i don't feel like improving it just yet
                //-----------------------------------------------------------------------------------Functions begin
                obj.draw = function (){//draw function for the game grid
                    for (w = 0; w < positions.length; w++){//nested for loop for ensuring that every grid space is updated
                        for (h = 0; h < positions[w].length; h++){
                            if ((positions[w][h]) == "r"){//if statement doing forked versions of the same commands for red or blue spaces
                                ctx.fillStyle = obj.oneColor;
                                ctx.fillRect(w*obj.width,h*obj.height,obj.width-2,obj.height-2);
                            }else if((positions[w][h]) == "b"){
                                ctx.fillStyle = obj.twoColor;
                                ctx.fillRect(w*obj.width,h*obj.height,obj.width-2,obj.height-2);
                            }
                        };
                    };
                    ctx.fillStyle = "#0008";//transparent overlay for whichever space the game cursor is at
                    ctx.fillRect(obj.mXO*obj.width-6,obj.mYO*obj.height-6,obj.width+10,obj.height+10);
                    console.log(obj.mXO,obj.mYO,obj.mposX,obj.mposY,obj.wait);
                };//---------------------------------------------------------------------------------draw end
                obj.mpos = function(){//parses the mouse position from the full width and height down to a multiple of 
                    //                      of the size of the game grid to ensure easy and correct cursor positioning
                    obj.mposX = parseInt(mouseX/obj.width);
                    obj.mposY = parseInt(mouseY/obj.height);
                };//---------------------------------------------------------------------------------mpos end
                obj.click = function(){
                    if (( !(obj.noX.includes(obj.mposX)) && !(obj.noY.includes(obj.mposY)) ) && obj.wait != 1){
                        if(mouseclick == true){
                            //console.log(positions[obj.mposX][obj.mposY]);
                            obj.mXO = obj.mposX;
                            obj.mYO = obj.mposY;
                            obj.flip();
                            //console.log(obj.mXO,obj.mYO)
                        }
                        
                        obj.wait = 1;
                    };
                };//---------------------------------------------------------------------------------hover end
                obj.keys = function(){
                    if( (keydown.a || keydown.left) && !(obj.noX.includes(obj.mXO-1)) && obj.wait != 1){
                            obj.mXO = obj.mXO-1;
                            obj.flip();
                            obj.wait = 1;
                        }if( (keydown.d || keydown.right ) && !(obj.noX.includes(obj.mXO+1)) && obj.wait != 1){
                            obj.mXO = obj.mXO+1;
                            obj.flip();
                            obj.wait = 1;
                        }if( (keydown.w || keydown.up) && !(obj.noY.includes(obj.mYO-1)) && obj.wait != 1){
                            obj.mYO = obj.mYO-1;
                            obj.flip();
                            obj.wait = 1;
                        }if( (keydown.s || keydown.down) && !(obj.noY.includes(obj.mYO+1)) && obj.wait != 1){
                            obj.mYO = obj.mYO+1;
                            obj.flip();
                            obj.wait = 1;
                        }
                };//---------------------------------------------------------------------------------keys end
                obj.mousepause = function(){//function for disallowing the player to select nonadjacent grid spaces
                    if ((( Math.abs(obj.mYO - obj.mposY) < 2 ) && Math.abs(obj.mXO - obj.mposX) < 2 ) && ( obj.mYO != obj.mposY || obj.mXO != obj.mposX) ){
                        if ( !(keydown.a || keydown.d || keydown.w || keydown.s || keydown.up || keydown.down || keydown.left || keydown.right)){
                            obj.wait = 0;
                        }
                    }
                    //console.log(obj.wait);
                };//---------------------------------------------------------------------------------mousepause end
                obj.flip = function(){//function for flipping all the grid spaces around the selected space
                    
                    if (positions[obj.mXO][obj.mYO] == "r"){
                        positions[obj.mXO][obj.mYO] = "b";
                    }else if (positions[obj.mXO][obj.mYO] == "b"){
                        positions[obj.mXO][obj.mYO] = "r"
                    }
                    try {
                    if (positions[obj.mXO-1][obj.mYO] == "r"){
                        positions[obj.mXO-1][obj.mYO] = "b";
                    }else if (positions[obj.mXO-1][obj.mYO] == "b"){
                        positions[obj.mXO-1][obj.mYO] = "r"
                    }
                    }
                    //any errors at this point, are irrelevant to the actual function of the game as it has been tested extensively
                    catch (err) {console.log("Error at line 169");}
                    try {
                    if (positions[obj.mXO][obj.mYO-1] == "r"){
                        positions[obj.mXO][obj.mYO-1] = "b";
                    }else if (positions[obj.mXO][obj.mYO-1] == "b"){
                        positions[obj.mXO][obj.mYO-1] = "r"
                    }
                    }
                    //any errors at this point, are irrelevant to the actual function of the game as it has been tested extensively
                    catch (err) {console.log("Error at line 178");}
                    try{
                    if (positions[obj.mXO][obj.mYO+1] == "r"){
                        positions[obj.mXO][obj.mYO+1] = "b";
                    }else if (positions[obj.mXO][obj.mYO+1] == "b"){
                        positions[obj.mXO][obj.mYO+1] = "r"
                    }
                    }
                    //any errors at this point, are irrelevant to the actual function of the game as it has been tested extensively
                    catch (err) {console.log("Error at line 187");}
                    try{
                    if (positions[obj.mXO+1][obj.mYO] == "r"){
                        positions[obj.mXO+1][obj.mYO] = "b";
                    }else if (positions[obj.mXO+1][obj.mYO] == "b"){
                        positions[obj.mXO+1][obj.mYO] = "r"
                    }
                    }
                    //any errors at this point, are irrelevant to the actual function of the game as it has been tested extensively
                    catch (err) {console.log("Error at line 196");}
                }
                return obj;//returns the game object for proper instantiation
            };//-------------------------------------------------------------------------------------thegame end
            
            var a = new thegame();
            
            function solveCheck(){//easy checker for seeing if the current puzzle has been solved
                var check = false;
                for (q = 0; q < positions.length; q++){
                    for (w = 0; w < positions[q].length; w++){
                        if (positions[q][w] == positions[0][0]){
                            check = true;
                            //console.log( q, w, positions[q][w], check);
                        }else{
                            check = false;
                            //console.log( q, w, positions[q][w], check, "break");
                            break;
                        }
                    }
                    if (check == false){
                        //console.log("full break");
                        break;
                    }
                }
                if (check == true){
                    return true;
                }
                
            };//-------------------------------------------------------------------------------------solveCheck end
            
            
            function init(){//reinitialization funciton for when the next level begins
                turn = 0;
                positions = [];
                positions = genPos();
                for (dif = 0; dif < difficulty; dif++){
                    a.mposX = parseInt(1+Math.random()*(size-2));
                    a.mposY = parseInt(1+Math.random()*(size-2));
                    a.flip();
                }
                difficulty ++;
                //console.log(positions);
            };
            init();//runs first initialization
            
            score = 0;//reverts score to zero externally so that it is not affected by above level progression init function
            setInterval(function(){
                ctx.clearRect(0,0,c.width,c.height);
                a.draw();
                a.mpos();
                a.click();
                a.mousepause();
                a.keys();
                if (solveCheck() == true){
                    
                    score ++;
                    
                    init();
                };
                scoretag.innerHTML = "Score:"+score;
                oldTime=Date.now();
                },0)
            
        </script>
    </body>
</html>
